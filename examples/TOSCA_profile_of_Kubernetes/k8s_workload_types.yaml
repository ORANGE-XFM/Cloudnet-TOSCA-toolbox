###############################################################################
# Software Name : Cloudnet TOSCA toolbox
# Version: 1.0
# SPDX-FileCopyrightText: Copyright (c) 2021 Orange
# SPDX-License-Identifier: Apache-2.0
#
# This software is distributed under the Apache License 2.0
# the text of which is available at http://www.apache.org/licenses/LICENSE-2.0
# or see the "LICENSE-2.0.txt" file for more details.
#
# Authors:
#   Frédéric Klamm <frederic.klamm@orange.com>
#
# Software description: TOSCA profile of K8S
###############################################################################

tosca_definitions_version: tosca_simple_yaml_1_3

description: Kubernetes 1.22 workload types definitions

metadata:
  template_name: k8s_workload_types
  template_author: fk
  template_version: 0.9

# No type in this profile is derived from an OASIS TOSCA profile type (§5) or from an ETSI NFV profile type.
# A lot of property constraints have been formalized in TOSCA based on their description in English in K8S JSON schema description fields.
# The presence of 'bound' in comments indicates the sentence expresses some complex constraint, typically between different properties.

imports:
  - k8s_cluster_types.yaml

artifact_types:

# artifact rather than datatype ?
  tosca.artifacts.iolab.k8s.ImagePullSecret:
    derived_from: tosca.artifacts.iolab.k8s.LocalObjectReference


data_types:

  tosca.datatypes.iolab.k8s.Affinity:
    derived_from: tosca.datatypes.Root  
    description: >-
      Affinity is a group of affinity scheduling rules.
    properties:
      nodeAffinity:
        description: >-
          Describes node affinity scheduling rules for the pod.
        type: tosca.datatypes.iolab.k8s.NodeAffinity
        required: false
      podAffinity:
        description: >-
          Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        type: tosca.datatypes.iolab.k8s.PodAffinity
        required: false
      podAntiAffinity:
        description: >-
          Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). 
        type: tosca.datatypes.iolab.k8s.PodAntiAffinity
        required: false
          
  tosca.datatypes.iolab.k8s.Capabilities:
    derived_from: tosca.datatypes.Root
    description: Adds and removes POSIX capabilities from running containers.
    properties:
      add:
        description: Added capabilities
        type: list
        entry_schema:
          type: string
        required: false
      drop:
        description: Removed capabilities
        type: list
        entry_schema:
          type: string
        required: false

  tosca.datatypes.iolab.k8s.ConfigMap:
    derived_from: tosca.datatypes.Root
    description: >-
      ConfigMap holds configuration data for pods to consume.
    properties:
      metaProperties:
        # The following description doesn't come from K8s (the same for a few others in this profile)
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      binaryData:
        description: >-
          BinaryData contains the binary data. Each key must consist of alphanumeric characters, '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range. 
          The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet.
        type: map
        entry_schema:
          type: string   # format : byte
      data:
        description: >-
          Data contains the configuration data. Each key must consist of alphanumeric characters, '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. 
          The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process.
        type: map
        entry_schema:
          type: string
      immutable:
        description: >-
          Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). 
          If not set to true, the field can be modified at any time. Defaulted to nil. This is an alpha field enabled by ImmutableEphemeralVolumes feature gate.
        type: boolean

  tosca.datatypes.iolab.k8s.ConfigMapEnvSource:
    description: >-
      ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.
      The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
    properties:
      name:
        description: >-
          Name of the referent.
        type: string
      optional:
        description: >-
          Specify whether the ConfigMap must be defined
        type: boolean
        required: false  #! so 'default' is missing in the k8s API

  tosca.datatypes.iolab.k8s.ConfigMapKeySelector:
    derived_from: tosca.datatypes.Root
    description: >-
      Selects a key from a ConfigMap.
    properties:
      key:
        description: >-
          The key to select.
        type: string
        required: true
      name:
        description: >-
          Name of the referent. 
        type: string
        required: false
      optional:
        description: >-
          Specify whether the ConfigMap or its key must be defined
        type: boolean
        required: false
    
  tosca.datatypes.iolab.k8s.ConfigMapVolumeSource:
    derived_from: tosca.datatypes.Root
    description: >-
      Adapts a ConfigMap into a volume. The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names,
       unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
    properties:
      defaultMode:
        description: >-
          Optional. mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting.
          This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        type: integer
        constraints:
          - in_range: [0, 777]
        default: 644
        required: false
      items:
        description: >-
          If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. 
          If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. 
          If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. 
          Paths must be relative and may not contain the '..' path or start with '..'.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.KeyToPath
        required: false
      name:
        description: >-
          Name of the referent.
        type: string
        required: false
      optional:
        description: >-
          Specify whether the ConfigMap or its keys must be defined
        type: boolean
        required: false

  #NFV  = Vdu.OsContainer, which is a TOSCA node for NFV, but Container is not defined as a K8S resource object.
  tosca.datatypes.iolab.k8s.Container:
    derived_from: tosca.datatypes.Root
    description: >-
      A single application container that you want to run within a pod.
    properties:
      args:
        description: >-
          Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. 
          If a variable cannot be resolved, the reference in the input string will be unchanged. Cannot be updated.
        type: list
        entry_schema:
          type: string
        required: false
      command:
        description: >-
          Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. 
          Variable references $(VAR_NAME) are expanded using the container's environment.
          If a variable cannot be resolved, the reference in the input string will be unchanged. Cannot be updated.
        type: list
        entry_schema:
          type: string
        required: false
      env:
        description: >-
          List of environment variables to set in the container. Cannot be updated.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.EnvVar
        required: false
      envFrom:
        description: >-
          List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. 
          All invalid keys will be reported as an event when the container is starting. 
          When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. 
          Cannot be updated.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.EnvFromSource
        required: false
      image:
        description: >-
          Docker image name. This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
        type: string
        required: false
      imagePullPolicy:
        description: >-
          Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated.
        type: string
        constraints:
         - valid_values: [ Always, Never, IfNotPresent ]
        default: Always
        required: false
      lifecycle:
        description: >-
          Actions that the management system should take in response to container lifecycle events. Cannot be updated.
        type: tosca.datatypes.iolab.k8s.Lifecycle
        required: false
      livenessProbe:
        type: tosca.datatypes.iolab.k8s.Probe
        description: >-
          Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated.
        required: false
      #> Can a pattern be defined to check that 'name' is a DNS label ?
      name:
        description: >-
          Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        type: string
        required: true
      ports:
        description: >-
          List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational.
          Not specifying a port here DOES NOT prevent that port from being exposed. 
          Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.ContainerPort
        required: false
      readinessProbe:
        description: >-
          Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated.
        type: tosca.datatypes.iolab.k8s.Probe
        required: false
      resources:
        description: Compute Resources required by this container. Cannot be updated.
        type: tosca.datatypes.iolab.k8s.ResourceRequirements
        required: false
      securityContext:
        description: >-
          Security options the pod should run with.
        type: tosca.datatypes.iolab.k8s.SecurityContext
        required: false
      startupProbe:
        description: >-
          StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. 
          If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. 
          This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, 
          than during steady-state operation. This cannot be updated. This is a beta feature enabled by the StartupProbe feature flag.
        type: tosca.datatypes.iolab.k8s.Probe
        required: false
      stdin:
        description: >-
          Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. 
          Default is false.
        type: boolean
        default: false
        required: false
      stdinOnce:
        description: >-
          Whether the container runtime should close the stdin channel after it has been opened by a single attach. 
          When stdin is true the stdin stream will remain open across multiple attach sessions. 
          If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects,
          at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
          Default is false.
        type: boolean
        default: false
        required: false
      terminationMessagePath:
        description: >-
          Optional. Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. 
          Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. 
          The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        type: string
        default: /dev/termination-log
        required: false
      terminationMessagePolicy:
        description: >-
          Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure.
          FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. 
          The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        type: string
        default: File
        required: false
      tty:
        description: >-
          Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
        type: boolean
        default: false
        required: false
      volumeDevices:
        description: >-
          volumeDevices is the list of block devices to be used by the container.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.VolumeDevice
        required: false
      volumeMounts:
        description: >-
          Pod volumes to mount into the container's filesystem. Cannot be updated.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.VolumeMount
        required: false
      workingDir:
        description: >-
          Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        type: string
        required: false

  tosca.datatypes.iolab.k8s.ContainerPort:
    derived_from: tosca.datatypes.Root
    description: >-
      ContainerPort represents a network port in a single container.
    properties:
      containerPort:
        description: >-
          Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        type: integer
        constraints:
          - in_range: [0, 65536]
        required: true
      hostIP:
        description: >-
          What host IP to bind the external port to.
        type: string
        required: false
      hostPort:
        description: >-
          Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. 
          Most containers do not need this.
        type: integer
        constraints:
          - in_range: [0, 65536]
        required: false
      name:
        description: >-
          If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
        type: string
        required: false
      protocol:
        description: >-
          Protocol for port. Must be UDP, TCP, or SCTP. Defaults to TCP.
        type: string
        constraints:
          - valid_values: [ TCP, UDP, SCTP]
        default: TCP
        required: false

  # Appears only in PodStatus (~ tosca: Pod attributes)
  tosca.datatypes.iolab.k8s.ContainerStatus:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.DeploymentCondition:
    derived_from: tosca.datatypes.Root
    description: >-
      DeploymentCondition describes the state of a deployment at a certain point.
    properties:
      lastTransitionTime:
        description: >-
          Last time the condition transitioned from one status to another.
        type: tosca.datatypes.iolab.k8s.Time
        required: false
      lastUpdateTime:
        description: >-
          The last time this condition was updated.
        type: tosca.datatypes.iolab.k8s.Time        
        required: false
      message:
        description: >-
          A human readable message indicating details about the transition.
        type: string
        required: false
      reason:
        description: >-
          The reason for the condition's last transition.
        type: string
        required: false
      status:
        description: >-
          Status of the condition, one of True, False, Unknown.
        type: string
        required: true
      type:
        description: >-
          Type of deployment condition.
        type: string
        required: true
          
  tosca.datatypes.iolab.k8s.DeploymentStrategy:
    derived_from: tosca.datatypes.Root
    description: >-
      DeploymentStrategy describes how to replace existing pods with new ones.
    properties:
      #! Existence is bound to the value of property 'type'.
      rollingUpdate:
        description: >-
          Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        type: tosca.datatypes.iolab.k8s.RollingUpdateDeployment
        required: false
      type:
        description: >-
          Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        type: string
        constraints:
          - valid_values: [ Recreate, RollingUpdate ]
        default: RollingUpdate
        required: false

  #NFV This type is added to replace the white map in ResourceRequirements specified by the K8S schema, with clearly-named fields 
  #     so that they match NFV requirements (cpu, memory,...), or such requirements in another domain
  tosca.datatypes.iolab.k8s.DetailedRequirements:
    derived_from: tosca.datatypes.Root
    description: >-
      Replace the free map in ResourceRequirements specified by the K8S schema by clearly-named fields.
    properties:
      #NFV = Vdu"."OSContainer.requested_cpu_resources or Vdu"."OSContainer.cpuResourceLimit
      cpu:
        type: tosca.datatypes.iolab.k8s.Quantity
        required: false
      #NFV = Vdu"."OSContainer.requested_memory_resources or Vdu"."OSContainer.memoryResourceLimit
      memory:
        type: tosca.datatypes.iolab.k8s.Quantity
        required: false
      #NFV = Vdu"."OSContainer.requested_ephemeral_storage_resources or Vdu"."OSContainer.ephemeralStorageResourceLimit
      ephemeral_storage:
        type: tosca.datatypes.iolab.k8s.Quantity
        required: false
      storage:
        type: tosca.datatypes.iolab.k8s.Quantity
        required: false

  tosca.datatypes.iolab.k8s.EmptyDirVolumeSource:
    derived_from: tosca.datatypes.Root
    description: >-
      Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
    properties:
      medium:
        description: >-
          What type of storage medium should back this directory. The default is "" which means to use the node's default medium. 
          Must be an empty string (default) or Memory.
        type: string
        default: ""
        required: false
      #! bound to the sum of memory limits of all containers in a pod (cf. description)
      sizeLimit:
        description: >-
          Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. 
          The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
          The default is nil which means that the limit is undefined.
        type: tosca.datatypes.iolab.k8s.Quantity
        ## default: nil requires tosca 2.0
        required: false
                          
  tosca.datatypes.iolab.k8s.EnvFromSource:
    derived_from: tosca.datatypes.Root
    description: >-
      EnvFromSource represents the source of a set of ConfigMaps
    properties:
      configMapRef:
        description: >-
          The ConfigMap to select from
        type: tosca.datatypes.iolab.k8s.ConfigMapEnvSource
        required: false
      prefix:
        description: >-
          An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        type: string
        required: false
      secretRef:
        description: >-
          The Secret to select from
        type: tosca.datatypes.iolab.k8s.SecretEnvSource
        required: false

  tosca.datatypes.iolab.k8s.EnvVar:
    derived_from: tosca.datatypes.Root
    description: >-
      EnvVar represents an environment variable present in a Container.
    properties:
      name:
        description: Name of the environment variable. Must be a C_IDENTIFIER.
        type: string
        required: true
      value:
        description: >-
          Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables.
          If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
          Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        type: string
        default: ""
        required: false
      #!  bound to emptiness of property 'value' (exclusive or)
      valueFrom:
        description: >-
          Source for the environment variable's value. Cannot be used if value is not empty.
        type: tosca.datatypes.iolab.k8s.EnvVarSource
        required: false
        
  tosca.datatypes.iolab.k8s.EnvVarSource:
    derived_from: tosca.datatypes.Root
    description: >-
      EnvVarSource represents a source for the value of an EnvVar.
    properties:
      configMapKeyRef:
        description: >-
          Selects a key of a ConfigMap.
        type: tosca.datatypes.iolab.k8s.ConfigMapKeySelector
        required: false
      #! fieldRef.FieldPath value is bound to the values that can be found in the fields mentionned in this description
      fieldRef:
        description: >-
          Selects a field of the pod.
          Supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        type: tosca.datatypes.iolab.k8s.ObjectFieldSelector
        required: false
      #! resourceFieldRef.FieldPath value is bound to the values that can be found in the fields mentionned in this description
      resourceFieldRef:
        description: >-
          Selects a resource of the container.
          Only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        type: tosca.datatypes.iolab.k8s.ResourceFieldSelector
        required: false
      secretKeyRef:
        description: >-
          Selects a key of a secret in the pod's namespace
        type: tosca.datatypes.iolab.k8s.SecretKeySelector
        required: false

  tosca.datatypes.iolab.k8s.ExecAction:
    derived_from: tosca.datatypes.Root
    description: ExecAction describes a "run in container" action.
    properties:
      command:
        description: >-
          Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem.
          The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work.
          To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        type: list
        entry_schema:
          type: string
        required: false
          
  tosca.datatypes.iolab.k8s.HostAlias:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.HTTPGetAction:
    derived_from: tosca.datatypes.Root
    description: >-
      HTTPGetAction describes an action based on HTTP Get requests.
    properties:
      host:
        description: >-
          Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        type: string
        required: false
      httpHeaders:
        description: >-
          Custom headers to set in the request. HTTP allows repeated headers.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.HTTPHeader
        required: false
      path:
        description: >-
          Path to access on the HTTP server.
        type: string
        required: false
      port:
        description: >-
          Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        type: string   #>> io.k8s.apimachinery.pkg.util.intstr.IntOrString
        required: true
      scheme:
        description: Scheme to use for connecting to the host. Defaults to HTTP.
        type: string
        default: HTTP
        required: false

  tosca.datatypes.iolab.k8s.HTTPHeader:
    derived_from: tosca.datatypes.Root
    description: >-
      HTTPHeader describes a custom header to be used in HTTP probes
    properties:
      name:
        description: >-
          The header field name
        type: string
        required: true
      value:
        description: The header field value
        type: string
        required: true
   
  tosca.datatypes.iolab.k8s.HTTPIngressPath:
    derived_from: tosca.datatypes.Root
    description: >-
      HTTPIngressPath associates a path with a backend. Incoming urls matching the path are forwarded to the backend.
    properties:
      backend:
        description: >-
          Backend defines the referenced service endpoint to which the traffic will be forwarded to.
        type: tosca.datatypes.iolab.k8s.IngressBackend
        required: true
      #> A pattern can be deduced from the description field
      path:
        description: >-
          Path is matched against the path of an incoming request.
          Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986. 
          Paths must begin with a '/'. When unspecified, all paths from incoming requests are matched.
        type: string
        required: false
      #! check whether pathType is bound to anything, based on its description
      pathType:
        description: >-
          PathType determines the interpretation of the Path matching. PathType can be one of the following values:
            * Exact: Matches the URL path exactly. 
            * Prefix: Matches based on a URL path prefix split by '/'. 
              Matching is done on a path element by element basis. A path element refers is the list of labels in the path split by the '/' separator.
              A request is a match for path p if every p is an element-wise prefix of p of the request path. 
              Note that if the last element of the path is a substring of the last element in request path, it is not a match (e.g. /foo/bar matches /foo/bar/baz, but does not match /foo/barbaz).
            * ImplementationSpecific: Interpretation of the Path matching is up to the IngressClass.
              Implementations can treat this as a separate PathType or treat it identically to Prefix or Exact path types.
              Implementations are required to support all path types. Defaults to ImplementationSpecific.
        type: string
        constraints:
          - valid_values: [ Exact, Prefix, ImplementationSpecific ]
        default: ImplementationSpecific
        required: false

  tosca.datatypes.iolab.k8s.HTTPIngressRuleValue:
    derived_from: tosca.datatypes.Root
    description: >-
      HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example
    properties:
      paths:
        description: A collection of paths that map requests to backends.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.HTTPIngressPath
        required: true

  tosca.datatypes.iolab.k8s.IngressBackend:
    derived_from: tosca.datatypes.Root
    description: >-
      IngressBackend describes all endpoints for a given service and port.
    properties:   #! conditional properties: 'resource' is bound to 'serviceName' and 'servicePort' (cf. description)
        resource:
          description: >-
            Resource is an ObjectRef to another Kubernetes resource in the namespace of the Ingress object. If resource is specified, serviceName and servicePort must not be specified.
          type: tosca.datatypes.iolab.k8s.TypedLocalObjectReference
          required: false
        serviceName:
          description: >-
            Specifies the name of the referenced service.
          type: string
          required: false
        servicePort:
          description: >-
            Specifies the port of the referenced service.
          type: string   ## io.k8s.apimachinery.pkg.util.intstr.IntOrString
          required: false

  tosca.datatypes.iolab.k8s.IngressRule:
    derived_from: tosca.datatypes.Root
    description: >-
      IngressRule represents the rules mapping the paths under a specified host to the related backend services. 
      Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue.
    properties:
      host:
        #>> Does a constraint in this description need to be formalized ?
        description: >-
          Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the "host" part of the URI as defined in RFC 3986 1.
          IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. The semicolumn delimiter is not respected because ports are not allowed.
          Currently the port of an Ingress is implicitly 80 for http and 443 for https. Both these may change in the future. 
          Incoming requests are matched against the host before the IngressRuleValue. 
          If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. 
          Host can be "precise" which is a domain name without the terminating dot of a network host or "wildcard", which is a domain name prefixed with a single wildcard label.
          The wildcard character must appear by itself as the first DNS label and matches only a single label. You cannot have a wildcard label by itself.
        type: string
        required: false
      http:
        type: tosca.datatypes.iolab.k8s.HTTPIngressRuleValue
        required: false

  tosca.datatypes.iolab.IngressTLS:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.KeyToPath:
    derived_from: tosca.datatypes.Root
    description: >-
      Maps a string key to a path within a volume.
    properties:
      key:
        description: The key to project.
        type: string
        required: true
      mode:
        description: >-
          Optional - mode bits to use on this file, must be a value between 0 and 0777.
          If not specified, the volume defaultMode will be used. 
          This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        #> format: int32
        type: integer
        constraints:
          - in_range: [ 0, 777 ]
        required: false
      path:
        description: >-
          The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        type: string
        required: true

  tosca.datatypes.iolab.k8s.Lifecycle:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.LoadBalancerIngress:
    derived_from: tosca.datatypes.Root
    description: >-
      LoadBalancerIngress represents the status of a load-balancer ingress point. Traffic intended for the service should be sent to an ingress point.
    properties:
      hostname:
        description: >-
          Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)
        type: string
        required: false
      ip:
        description: >-
          IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)
        type: string
        required: false

  ## used as attribute only (in tosca acception)
  tosca.datatypes.iolab.k8s.LoadBalancerStatus:
    derived_from: tosca.datatypes.Root
    description: >-
      LoadBalancerStatus represents the status of a load-balancer.
    properties:
      ingress:
        description: >-
          Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.LoadBalancerIngress
        required: false

  tosca.datatypes.iolab.k8s.LocalObjectReference:
    derived_from: tosca.datatypes.Root
    description: LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
    properties:
      name:
        description: Name of the referent.
        type: string
        required: false
 
  tosca.datatypes.iolab.k8s.NetworkPolicyEgressRule:
    derived_from: tosca.datatypes.Root
    description: >-
      NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector.
      The traffic must match both ports and to. This type is beta-level in 1.8
    properties:
      ports:
        description: >-
          List of destination ports for outgoing traffic. Each item in this list is combined using a logical OR.
          If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
          If this field is present and contains at least one item, then this rule allows traffic only if the traffic matches at least one port in the list.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.NetworkPolicyPort
        required: false
      to:
        description: >-
          List of destinations for outgoing traffic of pods selected for this rule. Items in this list are combined using a logical OR operation. 
          If this field is empty or missing, this rule matches all destinations (traffic not restricted by destination). 
          If this field is present and contains at least one item, this rule allows traffic only if the traffic matches at least one item in the to list.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.NetworkPolicyPeer
        required: false
          
  tosca.datatypes.iolab.k8s.NetworkPolicyIngressRule:
    derived_from: tosca.datatypes.Root
    description: >-
      NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
    properties:
      from:
        description: >-
          List of sources which should be able to access the pods selected for this rule. Items in this list are combined using a logical OR operation.
          If this field is empty or missing, this rule matches all sources (traffic not restricted by source). 
          If this field is present and contains at least one item, this rule allows traffic only if the traffic matches at least one item in the from list.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.NetworkPolicyPeer
        required: false
      ports:
        description: >-
          List of ports which should be made accessible on the pods selected for this rule. Each item in this list is combined using a logical OR. 
          If this field is empty or missing, this rule matches all ports (traffic not restricted by port). 
          If this field is present and contains at least one item, then this rule allows traffic only if the traffic matches at least one port in the list.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.NetworkPolicyPort
        required: false

  tosca.datatypes.iolab.k8s.NetworkPolicyPeer:
    derived_from: tosca.datatypes.Root
    
  tosca.datatypes.iolab.k8s.NetworkPolicyPort:
    derived_from: tosca.datatypes.Root
    description: >-
      NetworkPolicyPort describes a port to allow traffic on
    properties:
      port:
        description: >-
          The port on the given protocol. This can either be a numerical or named port on a pod. If this field is not provided, this matches all port names and numbers.
        type: string   #> this would be translated into k8s type io.k8s.apimachinery.pkg.util.intstr.IntOrString
        required: false
      protocol:
        description: >-
          The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
        type: string
        constraints:
          - valid_values: [TCP, UDP, SCTP ]
        required: false

  tosca.datatypes.iolab.k8s.NodeAffinity:
    derived_from: tosca.datatypes.Root
    description: >- 
      Node affinity is a group of node affinity scheduling rules.
    properties:
      preferredDuringSchedulingIgnoredDuringExecution:
        description: >-
          The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
          The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request,
          requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding weight to the sum 
          if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.PreferredSchedulingTerm
        required: false

  #> Appears in 2 contexts: EnvVarSource & DownwardAPIVolumeFile
  #> fieldPath valid values are bound to the used context (e.g. see EnvVarSource.fieldRef description)
  tosca.datatypes.iolab.k8s.ObjectFieldSelector:
    derived_from: tosca.datatypes.Root
    description: >-
      ObjectFieldSelector selects an APIVersioned field of an object.
    properties:
      apiVersion:
        description: >-
          Version of the schema the FieldPath is written in terms of, defaults to "v1".
        type: string
        default: v1
        required: false
      fieldPath:
        description: Path of the field to select in the specified API version.
        type: string
        required: true

  tosca.datatypes.iolab.k8s.PodAffinity:
    derived_from: tosca.datatypes.Root 
    description: >-
      Pod affinity is a group of inter pod affinity scheduling rules.
    properties:
      preferredDuringSchedulingIgnoredDuringExecution:
        description: >-
          The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
          The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request,
          requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum
          if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        type: list
        entry_schema: 
          type: tosca.datatypes.iolab.k8s.WeightedPodAffinityTerm
        required: false
      requiredDuringSchedulingIgnoredDuringExecution:
        description: >-
          If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
          If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update),
          the system may or may not try to eventually evict the pod from its node. 
          When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.PodAffinityTerm
        required: false

  tosca.datatypes.iolab.k8s.PodAffinityTerm:
    derived_from: tosca.datatypes.Root 
    description: >-
      Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with,
      where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.
    properties:
      labelSelector:
        description: >-
          A label query over a set of resources, in this case pods.
        type: tosca.datatypes.iolab.k8s.LabelSelector
        required: false
      namespaces:
        description: >-
          namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        type: list
        entry_schema:
          type: string
        required: false
      topologyKey:
        description: >-
          This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces,
          where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.
          Empty topologyKey is not allowed.
        type: string
        required: true
          
  tosca.datatypes.iolab.k8s.PodAntiAffinity:
    derived_from: tosca.datatypes.Root 
    description: >-
      Pod anti affinity is a group of inter pod anti affinity scheduling rules.
    properties:
      preferredDuringSchedulingIgnoredDuringExecution:
        description: >-
          The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
          The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, 
          requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum
          if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.WeightedPodAffinityTerm
        required: false

  ## PodCOndition undeveloped because it appears only in PodStatus    
  tosca.datatypes.iolab.k8s.PodCondition:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.PodDNSConfig:
   derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.PodReadinessGate:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.PodSecurityContext:
    derived_from: tosca.datatypes.Root
    description: >-
      PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext. 
      Field values of container.securityContext take precedence over field values of PodSecurityContext.
    properties:
      fsGroup:
        description: >-
          A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
          1. The owning GID will be the FSGroup
          2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
          3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        #  format: "int64"
        type: integer
        required: false
      fsGroupChangePolicy:
        description: >-
          fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. 
          This field will only apply to volume types which support fsGroup based ownership(and permissions).
          It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. 
          Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
        type: string
        constraints: 
          - valid_values: [ OnRootMismatch, Always ]
        default: Always
        required: false
      runAsGroup:
        description: >-
          The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.
          If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        # format: "int64"
        type: integer
        required: false
      #! bound to value in SecurityContext (cf. description)
      runAsNonRoot:
        description: >-
          Indicates that the container must run as a non-root user.
          If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does.
          If unset or false, no such validation will be performed. 
          May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        type: boolean
        required: false
        default: false
      #! bound to value in SecurityContext (cf. description)
      runAsUser:
        description: >-
          The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified.
          May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        # format: "int64"
        type: integer
        required: false
      seLinuxOptions:
        description: "The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container."
        type: tosca.datatypes.iolab.k8s.SELinuxOptions
        required: false
      supplementalGroups:
        description: >-
          A list of groups applied to the first process run in each container, in addition to the container's primary GID.
          If unspecified, no groups will be added to any container.
        type: list
        entry_schema:
          #  format: "int64"
          type: integer
        required: false
      sysctls:
        description: >-
          Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.Sysctl
        required: false
      #! bound to value in SecurityContext (cf. description)
      windowsOptions:
        description: >-
          The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. 
          If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        type: tosca.datatypes.iolab.k8s.WindowsSecurityContextOptions
        required: false

  tosca.datatypes.iolab.k8s.PodSpec:
    derived_from: tosca.datatypes.Root
    description: >-
      Pod is a description of a Pod.
    version: v1
    properties:
      activeDeadlineSeconds:
        type: integer
        required: false
      affinity:
        description: If specified, the pod's scheduling constraints
        type: tosca.datatypes.iolab.k8s.Affinity
        required: false
      automountServiceAccountToken:
        description: >-
          Indicates whether a service account token should be automatically mounted.
        type: boolean
        required: false
      containers:
        description: >-
          List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.Container
        required: true
      dnsConfig:
        type: tosca.datatypes.iolab.k8s.PodDNSConfig
        description: >-
          Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
        required: false
      dnsPolicy:
        description: >-
          Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. 
          DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
          To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet.
        type: string
        constraints:
          - valid_values: [ ClusterFirstWithHostNet, ClusterFirst, Default, None ]
        default: ClusterFirst
        required: false
      hostAliases:
        description: >-
          HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.HostAlias
        required: false
      hostIPC:
        description: >-
          Use the host's ipc namespace. Optional. Default to false.
        type: boolean
        default: false
        required: false
      hostNetwork:
        description: >-
          Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
        type: boolean
        default: false
        required: false
      hostPID:
        description: >-
          Use the host's pid namespace. Optional. Default to false.
        type: boolean
        default: false
        required: false
      hostname:
        description: >-
          Specifies the hostname of the Pod. If not specified, the pod's hostname will be set to a system-defined value.
        type: string
        required: false
#> may be interesting to interpretate initCOntainer as interface operation ?
  #      initContainers:
  #      description: List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container # are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated.
  #         type: list
  #        entry_schema:
  #        type: tosca.datatypes.iolab.k8s.Container
  #      required: false
      nodeName: # nominatedNodeName is potentially a requirement of some hosted_on type
        description: >-
          NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        type: string
        required: false
# alpha    overhead
# alpha    preemptionPolicy
      priority:
        description: >-
          The priority value. Various system components use this field to find the priority of the pod. 
          When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName.
          The higher the value, the higher the priority.
        type: integer
        required: false
      priorityClassName:
        description: >-
          If specified, indicates the pod's priority.
          "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority.
          Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        type: string
        required: false
      readinessGates:
        description: >-
          If specified, all readiness gates will be evaluated for pod readiness.
          A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True"
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.PodReadinessGate
        required: false
      restartPolicy:
        description: >-
          Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always.

        type: string
        constraints:
          - valid_values: [ Always, OnFailure, Never ]
        default: Always
        required: false
      runtimeClassName:
        description: >-
          RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
          If no RuntimeClass resource matches the named class, the pod will not be run.
          If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler.

        type: string
        required: false
      schedulerName:
        description: >-
          If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        type: string
        required: false
      securityContext:
        description: >-
          SecurityContext holds pod-level security attributes and common container settings. Optional. Defaults to empty.
          See type description for default values of each field.
        type: tosca.datatypes.iolab.k8s.PodSecurityContext
        #>> in TOSCA_2_0,  default':' nil   could be added (semi-column without quotation)
        required: false
     # serviceAccount is deprecated
      serviceAccount:
        description: >-
          DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated. Use serviceAccountName instead.
        type: string
        required: false
      serviceAccountName:
        description: >-
          ServiceAccountName is the name of the ServiceAccount to use to run this pod.
        type: string
        required: false
      shareProcessNamespace:
        description: >-
          Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod,

          and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional. Default to false.
        type: boolean
        default: false
        required: false
      subdomain:
        description: >-
          If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
        type: string
        required: false
#> terminationGracePeriodSeconds could be interpreted as input for a podStop operation in PodLcm interface (?)
  #    terminationGracePeriodSeconds:
  #      description: >-
  #        Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately.
  #        If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal
  #        and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
  #      type: integer
  #      default: 30
  #      required: false
      tolerations:
        description: >-
          If specified, the pod's tolerations.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.Toleration
        required: false
      topologySpreadConstraints:
        description: >-
          TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.

          This field is only honored by clusters that enable the EvenPodsSpread feature. All topologySpreadConstraints are ANDed.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.TopologySpreadConstraint
        required: false
      volumes:
        description: >-
          List of volumes that can be mounted by containers belonging to the pod.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.Volume
        required: false
      # alpha     enableServiceLinks
      # alpha     ephemeralContainers


  tosca.datatypes.iolab.k8s.PodTemplateSpec:
    derived_from: tosca.datatypes.iolab.k8s.PodSpec
    description: >-
      PodTemplateSpec describes the data a pod should have when created from a template.
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
 
  tosca.datatypes.iolab.k8s.PolicyRule:
    derived_from: tosca.datatypes.Root
    description: >-
      PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
    properties:
      apiGroups:
        description: >-
          APIGroups is the name of the APIGroup that contains the resources.
          If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.
        type: list
        entry_schema:
          type: string
        required: false 
      nonResourceURLs:
        description: >-
          NonResourceURLs is a set of partial urls that a user should have access to. *s are allowed, but only as the full, final step in the path.
          Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
          Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
        type: list
        entry_schema:
          type: string
        required: false
      resourceNames:
        description: >-
          ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
        type: list
        entry_schema:
          type: string
        required: false
      resources:
        description: >-
          Resources is a list of resources this rule applies to.  ResourceAll represents all resources.
        type: list
        entry_schema:
          type: string
        required: false
      verbs:
        description: >-
          Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule.  VerbAll represents all kinds.
        type: list
        entry_schema:
          type: string
        required: true
    
  tosca.datatypes.iolab.k8s.PreferredSchedulingTerm:
    derived_from: tosca.datatypes.Root
    description: >-
      An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
    properties:
      preference:
        description: >-
          A node selector term, associated with the corresponding weight.
        type: tosca.datatypes.iolab.k8s.NodeSelectorTerm
        required: true
      weight:
        description: >-
          Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        type: integer
        constraints:
          - in_range: [ 1, 100]
        required: true

  tosca.datatypes.iolab.k8s.Probe:
    derived_from: tosca.datatypes.Root
    description: >-
      Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
    properties:
      exec:
        description: >-
          One and only one of the following should be specified. Exec specifies the action to take.
        type: tosca.datatypes.iolab.k8s.ExecAction
        required: false
      failureThreshold:
        description: >-
          Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        # format: "int32"
        type: integer
        #!! constraint is not formalized in the k8s API
        constraints:
          - greater_or_equal: 1
        #!! default value is not formalized in the k8s API
        default: 3
        required: false
      httpGet:
        description: >-
          HTTPGet specifies the http request to perform.
        type: tosca.datatypes.iolab.k8s.HTTPGetAction
        required: false
      initialDelaySeconds:
        description: >-
          Number of seconds after the container has started before liveness probes are initiated.
        #  format: "int32"
        type: integer
        required: false
      periodSeconds:
        description: >-
          How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        # format: "int32"
        type: integer
       #!! constraint is not formalized in the k8s API
        constraints:
          - greater_or_equal: 1
        #!! default value is not formalized in the k8s API
        default: 10
        required: false
      successThreshold:
        description: >-
          Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
        # format: "int32"
        type: integer
       #!! constraint is not formalized in the k8s API
        constraints:
          - greater_or_equal: 1
        #!! default value is not formalized in the k8s API
        default: 1
        required: false
      tcpSocket:
        description: >-
          TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        type: tosca.datatypes.iolab.k8s.TCPSocketAction
        required: false
      timeoutSeconds:
        description: >-
          Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1.
        # format: "int32"
        type: integer
        #!! default value is not formalized in the k8s API
        default: 1
        required: false

  tosca.datatypes.iolab.k8s.ResourceFieldSelector:
    derived_from: tosca.datatypes.Root
    description: ResourceFieldSelector represents container resources (cpu, memory) and their output format
    properties:
      # existence bound to context (cf. description)
      containerName:
        description: >-
          Container name. Required for volumes, optional for env vars
        type: string
        required: false
      divisor:
        description: >-
          Specifies the output format of the exposed resources, defaults to "1"
        type: tosca.datatypes.iolab.k8s.Quantity
        default: "1"
        required: false
      resource:
        description: >-
          Required. Resource to select
        type: string
        required: true

  tosca.datatypes.iolab.k8s.ResourceRequirements:
    derived_from: tosca.datatypes.Root
    description: >-
      ResourceRequirements describes the compute resource requirements.
    properties:
      limits:
        description: >-
          Limits describes the maximum amount of compute resources allowed.
        type: tosca.datatypes.iolab.k8s.DetailedRequirements
        required: false
      requests:
        description: >-
          Requests describes the minimum amount of compute resources required. 
          If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. 
        type: tosca.datatypes.iolab.k8s.DetailedRequirements
        required: false

  tosca.datatypes.iolab.k8s.Role:
    derived_from: tosca.datatypes.Root
    description: >-
      Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      rules:
        description: >-
          Rules holds all the PolicyRules for this Role
        type: list
        entry_schema:
          type:  tosca.datatypes.iolab.k8s.PolicyRule
        required: false

  tosca.datatypes.iolab.k8s.RoleBinding:
    derived_from: tosca.datatypes.Root
    description: >-
      RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace.
      It adds who information via Subjects and namespace information by which namespace it exists in. RoleBindings in a given namespace only have effect in that namespace.
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      roleRef:
        description: >- 
          RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.
          If the RoleRef cannot be resolved, the Authorizer must return an error.
        type: tosca.datatypes.iolab.k8s.RoleRef
        required: true
      subjects:
        description: >-
          Subjects holds references to the objects the role applies to.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.Subject
        required: false

  tosca.datatypes.iolab.k8s.RoleRef:
    derived_from: tosca.datatypes.Root
    description: >-
      RoleRef contains information that points to the role being used
    properties:
      apiGroup:
        description: APIGroup is the group for the resource being referenced
        type: string
        required: true
      kind:
        description: Kind is the type of resource being referenced
        type: string
        required: true
      name:
        description: Name is the name of resource being referenced
        type: string
        required: true
 
  tosca.datatypes.iolab.k8s.RollingUpdateDeployment:
    derived_from: tosca.datatypes.Root
    description: >-
      Spec to control the desired behavior of rolling update.
    properties:
      maxSurge:
        description: >-
          The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex. 5) or a percentage of desired pods (ex. 10%). 
          This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example. 
          When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods.
          Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
        type: string    # this would be translated into k8s type io.k8s.apimachinery.pkg.util.intstr.IntOrString
        required: false
      maxUnavailable:
        description: >-
          The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). 
          Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. 
          Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. 
          Once new pods are ready, old ReplicaSet can be scaled down #further, followed by scaling up the new ReplicaSet, 
          ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
        type: string    # this would be translated into k8s type io.k8s.apimachinery.pkg.util.intstr.IntOrString
        required: false

  tosca.datatypes.iolab.k8s.RollingUpdateStatefulSetStrategy:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.Secret:
    derived_from: tosca.datatypes.Root
    description: >-
      Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      data:
        description: >-
          Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. 
          The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in rfc4648, section-4.
        type: map
        entry_schema:
          type: string
        required: false
          # format: "byte"
#>> Alpha      immutable:
#        description: >-
#          Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). 
#          If not set to true, the field can be modified at any time. Defaulted to nil. This is an alpha field enabled by ImmutableEphemeralVolumes feature gate.
#        type: boolean
      stringData:
        description: >-
          stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. 
          All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API.
        type: map
        entry_schema:
          type: string
        required: false
      type:
        description: >-
          Used to facilitate programmatic handling of secret data.
        type: string
        required: false
              
  tosca.datatypes.iolab.k8s.SecretEnvSource:
    derived_from: tosca.datatypes.Root
    description: >-
      SecretEnvSource selects a Secret to populate the environment variables with. The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
    properties:
      name:
        description: >-
          Name of the referent.
        type: string
        required: false
      optional:
        description: >-
          Specify whether the Secret must be defined
        type: boolean
        required: false

  tosca.datatypes.iolab.k8s.SecretKeySelector:
    derived_from: tosca.datatypes.Root
    description: SecretKeySelector selects a key of a Secret.
    properties:
      key:
        description: >-
          The key of the secret to select from.  Must be a valid secret key.
        type: string
        required: true
      name:
        description: >-
          Name of the referent. 
        type: string
        required: false
      optional:
        description: Specify whether the Secret or its key must be defined
        type: boolean
        required: false

  #>> The value of certain properties is bound to a value of a property of type PodSecurityContext (cf. decriptions)
  tosca.datatypes.iolab.k8s.SecurityContext:
    derived_from: tosca.datatypes.Root
    description: >-
      SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext. 
      When both are set, the values in SecurityContext take precedence.
    properties:
      allowPrivilegeEscalation:
        description: >-
          AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process.
          This bool directly controls if the no_new_privs flag will be set on the container process. 
          AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN"
        type: boolean
        #!! default isn't set (to false) in the k8s API, neither formally nor in description
        required: false
      capabilities:
        description: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        type: tosca.datatypes.iolab.k8s.Capabilities
        required: false
      privileged:
        description: >-
          Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        type: boolean
        default: false
        required: false
      procMount:
        description: >-
          procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths.
          This requires the ProcMountType feature flag to be enabled.
        type: string
        required: false
      readOnlyRootFilesystem:
        description: >-
          Whether this container has a read-only root filesystem. Default is false.
        type: boolean
        default: false
        required: false
      runAsGroup:
        description: >-
          The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.
          If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        # format: "int64"
        type: integer
        required: false
      runAsNonRoot:
        description: >-
          Indicates that the container must run as a non-root user.
          If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does.
          If unset or false, no such validation will be performed. May also be set in PodSecurityContext.
          If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        type: boolean
        required: false
        default: false
      runAsUser:
        description: >-
          The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.
          If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        # format: "int64"
        type: integer
        required: false
      seLinuxOptions:
        description: >-
          The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.
          May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence."
        type: tosca.datatypes.iolab.k8s.SELinuxOptions
        required: false
      windowsOptions:
        description: >-
          The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. 
          If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        type: tosca.datatypes.iolab.k8s.WindowsSecurityContextOptions
        required: false

  tosca.datatypes.iolab.k8s.SELinuxOptions:
    derived_from: tosca.datatypes.Root
      
  tosca.datatypes.iolab.k8s.ServicePort:   #NFV = ServicePortData
    derived_from: tosca.datatypes.Root
    description: >-
      ServicePort contains information on service's port.
    properties:
      appProtocol:
        description: >-
          The application protocol for this port. This field follows standard Kubernetes label syntax. 
          Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). 
          Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol. Field can be enabled with ServiceAppProtocol feature gate.
        type: string
        required: false
      name:
        description: >-
          The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. 
          When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
        type: string
      nodePort:
        description: >-
          The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. 
          If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one.
        type: integer
        required: false
      port:
        description: >-
          The port that will be exposed by this service.
        type: integer
        required: true
      protocol:
        description: >-
          The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        type: string
        constraints:
          - valid_values: [ TCP, UDP, SCTP]
        default: TCP
      targetPort:
        type: string  #>> io.k8s.apimachinery.pkg.util.intstr.IntOrString
        description: >-
          Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
          If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map).
          This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field.
#> !!!! required must be set to true as soon as NFV provide it !!!!
        required: false

  tosca.datatypes.iolab.k8s.SessionAffinityConfig:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.ServiceAccount:
    derived_from: tosca.datatypes.Root
    description: >-
      ServiceAccount binds together
      * a name, understood by users, and perhaps by peripheral systems, for an identity 
      * a principal that can be authenticated and authorized 
      * a set of secrets
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      automountServiceAccountToken:
        description: >-
          AutomountServiceAccountToken ind.Affkkkkicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level.
        type: boolean
        required: false
      imagePullSecrets:
        description: >-
          ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount.
          ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.LocalObjectReference
        required: false
      secrets:
        description: >-
          Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.LocalObjectReference
        required: false
# TODO         "x-kubernetes-patch-merge-key": "name",
# TODO         "x-kubernetes-patch-strategy": "merge"

  tosca.datatypes.iolab.k8s.StatefulSetUpdateStrategy:
    derived_from: tosca.datatypes.Root
    description: >-
      StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. 
      It includes any additional parameters necessary to perform the update for the indicated strategy.
    properties:
      rollingUpdate:
        description: >-
          RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
        type: tosca.datatypes.iolab.k8s.RollingUpdateStatefulSetStrategy
        required: false
      type:
        description: >-
          Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        type: string
        default: RollingUpdate
        required: false

  tosca.datatypes.iolab.k8s.Subject:
    derived_from: tosca.datatypes.Root
    description: >-
      Subject contains a reference to the object or user identities a role binding applies to. 
      This can either hold a direct API object reference, or a value for non-objects such as user and group names.
    properties:
      apiGroup:
        description: >-
          APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. 
          Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
        type: string
        default: "rbac.authorization.k8s.io"
      kind:
        description: >-
          Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
          If the Authorizer does not recognized the kind value, the Authorizer should report an error.
        type: string
        constraints:
          - valid_values: [ User, Group, ServiceAccount ]
        required: true
      name:
         description: Name of the object being referenced.
         type: string
         required: true
      namespace:
        description: >-
          Namespace of the referenced object. 
          If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
        type: string
        required: false
        
  tosca.datatypes.iolab.k8s.Sysctl:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.TCPSocketAction:
    derived_from: tosca.datatypes.Root
    description: >-
      TCPSocketAction describes an action based on opening a socket
    properties:
      host:
        description: >-
          Optional: Host name to connect to, defaults to the pod IP.
        type: string
        required: false
      port:
        description: >-
          Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME."
        type: string  #>> io.k8s.apimachinery.pkg.util.intstr.IntOrString
        required: true
        
  tosca.datatypes.iolab.k8s.Toleration:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.TopologySpreadConstraint:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.Volume:
    derived_from: tosca.datatypes.Root
    description: >-
      Volume represents a named volume in a pod that may be accessed by any container in the pod.
    properties:
      configMap:
        description: >-
          ConfigMap represents a configMap that should populate this volume
        type: tosca.datatypes.iolab.k8s.ConfigMapVolumeSource
        required: false
      name:
        description: >-
          Volume's name. Must be a DNS_LABEL and unique within the pod.
        type: string
        required: true
      # 'persistentVolumeClaim'is modelled as a pod or StatefulSet requirement 
      # persistentVolumeClaim:
      #   description: PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
      #   type: tosca.datatypes.iolab.k8s.PersistentVolumeClaimVolumeSource

#>>    awsElasticBlockStore: 	#>> b, P, CSI
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource",
#>>          "description": "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod.
#>>        "azureDisk": {   #>>  b, P, csi   host mount bound to pod 
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.AzureDiskVolumeSource",
#>>          "description": "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
#>>        "azureFile": {   #>> f, P, csi   host mount bound to pod 
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.AzureFileVolumeSource",
#>>          "description": "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
#>>        "cephfs": {   #>> f, T, 
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.CephFSVolumeSource",
#>>          "description": "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime"
#>>        "cinder": {   #>> b, P, CSI
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.CinderVolumeSource",
#>>          "description": "Cinder represents a cinder volume attached and mounted on kubelets host machine.
#>>      "csi": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.CSIVolumeSource",
#>>          "description": "CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
#>>        "downwardAPI": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.DownwardAPIVolumeSource",
#>>          "description": "DownwardAPI represents downward API about the pod that should populate this volume"
      emptyDir:
        description: >-
          EmptyDir represents a temporary directory that shares a pod's lifetime.
        type: tosca.datatypes.iolab.k8s.EmptyDirVolumeSource
        required: false
#>>       "fc": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.FCVolumeSource",
#>>          "description": "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#>>        "flexVolume": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.FlexVolumeSource",
#>>          "description": "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
#>>        "flocker": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.FlockerVolumeSource",
#>>          "description": "Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running"
#>>        "gcePersistentDisk": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.GCEPersistentDiskVolumeSource",
#>>          "description": "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod.
#>>        "gitRepo": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.GitRepoVolumeSource",
#>>          "description": "GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.        },
#>>        "glusterfs": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.GlusterfsVolumeSource",
#>>          "description": "Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
#>>        "hostPath": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.HostPathVolumeSource",
#>>          "description": "HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this.
#>>        "iscsi": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.ISCSIVolumeSource",
#>>          "description": "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod.
#>>        "nfs": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.NFSVolumeSource",
#>>          "description": "NFS represents an NFS mount on the host that shares a pod's lifetime
#>>        "photonPersistentDisk": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource",
#>>          "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
#>>        "portworxVolume": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.PortworxVolumeSource",
#>>          "description": "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine"
#>>        "projected": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.ProjectedVolumeSource",
#>>          "description": "Items for all in one resources secrets, configmaps, and downward API"
#>>        "quobyte": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.QuobyteVolumeSource",
#>>          "description": "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
#>>        "rbd": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.RBDVolumeSource",
#>>          "description": "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md"
#>>        "scaleIO": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.ScaleIOVolumeSource",
#>>          "description": "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes."
#>>       "secret": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.SecretVolumeSource",
#>>          "description": "Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret"
#>>        "storageos": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.StorageOSVolumeSource",
#>>          "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes."
#>>        "vsphereVolume": {
#>>          "$ref": "#/definitions/io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource",
#>>          "description": "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine"

  tosca.datatypes.iolab.k8s.VolumeDevice:
    derived_from: tosca.datatypes.Root

  tosca.datatypes.iolab.k8s.VolumeMount:
    derived_from: tosca.datatypes.Root
    description: >-
      VolumeMount describes a mounting of a Volume within a container.
    properties:
      mountPath:
        description: >-
          Path within the container at which the volume should be mounted.  Must not contain ':'.
        type: string
        required: true
      mountPropagation:
        description: >-
          mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
        type: string
        required: false
      name:
        description: >-
          This must match the Name of a Volume.
        type: string
        required: true
      readOnly:
        description: >-
          Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        type: boolean
        default: false
        required: false
      # !! Default unset because description are not the same in json API and API reference doc
      subPath:
        description: >-
          Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).
        type: string
        required: false
      subPathExpr:
        description: >-
          Expanded path within the volume from which the container's volume should be mounted. 
          Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. 
          Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
        type: string
        required: false

  tosca.datatypes.iolab.k8s.WeightedPodAffinityTerm:
    derived_from: tosca.datatypes.Root
    description: >-
      The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).
    properties:
      podAffinityTerm:
        description: >-
          Required. A pod affinity term, associated with the corresponding weight.
        type: tosca.datatypes.iolab.k8s.PodAffinityTerm
        required: true
      weight:
        description: >-
          weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
          "format": "int32",
        type: integer
        required: true

  tosca.datatypes.iolab.k8s.WindowsSecurityContextOptions:
    derived_from: tosca.datatypes.Root

capability_types:

  tosca.capabilities.iolab.k8s.Exposition:
    derived_from: tosca.capabilities.Node
    description: >-
      The capability of a K8S Service to expose an application running on a set of K8S Pods as a network service.
    properties:
      selector:
        description: > 
          'selector' maps onto the field 'selector' of the K8S resource object
#       type: tosca.datatypes.iolab.k8s.LabelSelector
        type: map
        entry_schema:
          type: string
        required: false
 
  #>> Relationship targets used to express application dependency requirements, as opposed to tosca.groups.iolab.k8s.PodLabel
  tosca.capabilities.iolab.k8s.PodLabels:
    derived_from: tosca.capabilities.Root
    description: >-
      Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
    properties:
      labels:
        type: map
        entry_schema:
          type: string
        required: false
    valid_source_types: [ tosca.nodes.iolab.k8s.Service ]
    
  #>> Relationship targets used to express application dependency requirements, as opposed to tosca.groups.iolab.k8s.PodLabel
  tosca.capabilities.iolab.k8s.PodLabel:
    derived_from: tosca.capabilities.Root
    description: >-
      Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
    properties:
      labelKey:
        type: string
        required: true
      labelValue:
        type: string
        required: true
    valid_source_types: [ tosca.nodes.iolab.k8s.Service ]


#NFV: in VirtualStorage
  tosca.capabilities.iolab.k8s.Pvc:
    derived_from: tosca.capabilities.Node
    description: >-
      PVC metadata name is used to select a PVC from a PodSpec.
    #>> In complex situations, e.g. with multiple cluster, it could be replaced with, e.g. uid or some combination metadata namespace, name, clusteName...
    valid_source_types: [ tosca.nodes.iolab.k8s.Pod, tosca.nodes.iolab.k8s.Deployment, tosca.nodes.iolab.k8s.StatefulSet ]

  tosca.capabilities.iolab.k8s.ClusterIP:
    derived_from: tosca.capabilities.Node
    description: >-
      k8s Service type set to 'ClusterIP'
#    valid_source_types: [ tosca.nodes.iolab.k8s.ClusterIPService ]

  tosca.capabilities.iolab.k8s.ExternalName:
    derived_from: tosca.capabilities.Root
    description: >-
      k8s Service type set to 'ExternalName'
    valid_source_types: [ tosca.nodes.iolab.k8s.Service ]

  tosca.capabilities.iolab.k8s.LoadBalancer:
    derived_from: tosca.capabilities.Root
    description: >-
      k8s Service type set to 'loadBalancer'
    valid_source_types: [ tosca.nodes.iolab.k8s.Service ]

#  tosca.capabilities.iolab.k8s.NodePort:
#    derived_from: tosca.capabilities.Root
#    description: >-
#      k8s Service type set to 'NodePort'
#    valid_source_types: [ tosca.nodes.iolab.k8s.Service ]


interface_types:
  tosca.interfaces.iolab.k8s.PodLcm:
    derived_from: tosca.interfaces.Root
    operations:
      podStart:    # tosca interpretation of the k8s PodSpec field initContainers
        description: >-
          List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started.
          If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy.
          The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
          The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, 
          and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. 
          Init containers cannot currently be added or removed. Cannot be updated.
        implementation:
          primary: initContainers    # ordered list of Containers represented in k8S initContainers field of PodSpec

      # tosca interpretation of the k8s PodSpec field terminationGracePeriodSeconds
      podStop:
        # The following description doesn't come from K8s
        description: >-
          Part of tosca interpretation of the k8s PodSpec field terminationGracePeriodSeconds
        inputs:
          terminationGracePeriodSeconds:    # tosca interpretation of the k8s PodSpec field terminationGracePeriodSeconds
            description: >-
              Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer.
              The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead.
              The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal.
              Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
            type: integer
            default: 30


relationship_types:

  tosca.relationships.iolab.k8s.ExposedAs:
    derived_from: tosca.relationships.Root
    valid_target_types: [ tosca.capabilities.iolab.k8s.Exposition ]
        
  #NFV: in AttachesTo
  tosca.relationships.iolab.k8s.PersistentVolumeClaiming:
    derived_from: tosca.relationships.Root
    valid_target_types: [ tosca.capabilities.iolab.k8s.Pvc ]


node_types:

# The TOSCA type properties capture in metaProperties the Kubernetes states that can be specified by users in the corresponding object metadata.
# They also capture directly the properties defined in Kubernetes objec Spec, except when their semantics matches with another TOSCA entity than 'datatype', or one of its specific keyname.
# The TOSCA type attributes capture in metaAttributes the Kubernetes states populated by the system that one can find in the corresponding object metadata.
# They also capture directly the attributes defined in Kubernetes objec Status, except when their semantics matches with another TOSCA entity than 'datatype', or one of its specific keyname.


  tosca.nodes.iolab.k8s.Deployment:
    derived_from: tosca.nodes.Root
    description: Deployment enables declarative updates for Pods and ReplicaSets.
    properties:   # matches DeploymentSpec, the specification of the desired behavior of the Deployment.
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      minReadySeconds:
        description: >-
          Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. 
          Defaults to 0 (pod will be considered available as soon as it is ready).
        # format: int32
        type: integer
        default: 0
        required: false
      paused:
        description: >-
          Indicates that the deployment is paused.
        type: boolean
        required: false
      progressDeadlineSeconds:
        description: >-
          The maximum time in seconds for a deployment to make progress before it is considered to be failed.
          The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status.
          Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
        # format: int32
        type: integer
        default: 600
        required: false
      replicas:
        description: >-
          Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        # format: int32
        type: integer
        default: 1
        required: false
      revisionHistoryLimit:
        description: >-
          The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
        # format: int32
        type: integer
        default: 10
        required: false
      selector:
        description: >-
          Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
        type: tosca.datatypes.iolab.k8s.LabelSelector
        required: true
      strategy:
        description: >-
          The deployment strategy to use to replace existing pods with new ones.
        type: tosca.datatypes.iolab.k8s.DeploymentStrategy
        required: false
#        "x-kubernetes-patch-strategy": "retainKeys"
      template:
        description: >-
          Template describes the pods that will be created.  
        type: tosca.datatypes.iolab.k8s.PodTemplateSpec
        required: true  
    attributes: #    K8S DeploymentStatus, i.e. the most recently observed status of the Deployment.
      availableReplicas:
        description: >-
          Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
        # format: int32
        type: integer
      collisionCount:
        description: >-
          Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.
        # format: int32
        type: integer
      conditions:
        description: Represents the latest available observations of a deployment's current state.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.DeploymentCondition
#>        "x-kubernetes-patch-merge-key": "type",
#>        "x-kubernetes-patch-strategy": "merge"
      observedGeneration:
        description: >-
          The generation observed by the deployment controller.
        # format: int64
        type: integer
      readyReplicas:
        description: >-
          Total number of ready pods targeted by this deployment.
        # format: int32
        type: integer
      replicas:
        description: >-
          Total number of non-terminated pods targeted by this deployment (their labels match the selector).
        # format: "int32
        type: integer
      unavailableReplicas:
        description: >-
          Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity.
          They may either be pods that are running but not yet available or pods that still have not been created.
        # format: int32
        type: integer
      updatedReplicas:
        description: >-
          Total number of non-terminated pods targeted by this deployment that have the desired template spec.
        # format: int32
        type: integer

    requirements:
        #NFV: virtual_storage
      - persistent_volume_claim:
          capability: tosca.capabilities.iolab.k8s.Pvc
          relationship: tosca.relationships.iolab.k8s.PersistentVolumeClaiming
          occurrences: [ 0, UNBOUNDED ]
      - exposing:
          capability: tosca.capabilities.iolab.k8s.Exposition
          relationship: tosca.relationships.iolab.k8s.ExposedAs
          occurrences: [ 0, UNBOUNDED ]          

    #> artifacts: property imagePullSecrets can be interpreted as an artifact.
      # imagePullSecrets:
      #  description: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored.
      #  type: list
      #    entry_schema:
      #    type: tosca.artifacts.iolab.k8s.LocalObjectReference

    interfaces:
      podLcm:
        type: tosca.interfaces.iolab.k8s.PodLcm


  tosca.nodes.iolab.k8s.Ingress:
    derived_from: tosca.nodes.Root
    description: >-
      Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. 
      An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
    properties:   #>> backend and rules are conditional
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      backend:
        description: >-
          A default backend capable of servicing requests that don't match any rule. At least one of 'backend' or 'rules' must be specified.
          This field is optional to allow the loadbalancer controller or defaulting logic to specify a global default.
        type: tosca.datatypes.iolab.k8s.IngressBackend
      ingressClassName:
        description: >-
          IngressClassName is the name of the IngressClass cluster resource. The associated IngressClass defines which controller will implement the resource.
          This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it must be given precedence over this field. 
          The controller may emit a warning if the field and annotation have different values. Implementations of this API should ignore Ingresses without a class specified. 
          An IngressClass resource may be marked as default, which can be used to set a default value for this field.
        type: string
      rules:
        description: >-
          A list of host rules used to configure the Ingress. If unspecified, or no rule matches, all traffic is sent to the default backend.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.IngressRule
      tls:
        description: >-
          TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts,
          they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.IngressTLS
    attributes:
      loadBalancer:   #!! no possible loop?
        description: >-
          LoadBalancer contains the current status of the load-balancer.
        type: tosca.datatypes.iolab.k8s.LoadBalancerStatus

  #NFV: = OsContainerDeployableUnit without controller
  tosca.nodes.iolab.k8s.Pod:
    derived_from: tosca.nodes.Root
    description: >-
      Pod is a collection of containers that can run on a host.
    version: v1
    properties:
      metaProperties:
        #>> Following description doesn't come from K8s
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      spec:
        description: >-
          Specification of the desired behavior of the pod.
        type: tosca.datatypes.iolab.k8s.PodSpec
        required: true
    # The following attributes captures the Kubernetes PodStatus type, that is the pod's actual state.
    attributes:
      metaAttributes:
        description: >-
          The Kubernetes states that is populated by the system in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaAttributes
      conditions:
        description: Current service state of pod.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.PodCondition
      containerStatuses:
        description: >-
          The list has one entry per container in the manifest. Each entry is currently the output of `docker inspect`.
        type: list
        entry_schema:
           type: tosca.datatypes.iolab.k8s.ContainerStatus
# alpha      ephemeralContainerStatuses:
      hostIP:
        description: >-
          IP address of the host to which the pod is assigned. Empty if not yet scheduled.
        type: string
      initContainerStatuses:
        description: >-
          The list has one entry per init container in the manifest. The most recent successful init container will have ready = true, the most recently started container will have startTime set.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.ContainerStatus
      message:
        description: >-
          A human readable message indicating details about why the pod is in this condition.
        type: string
      nominatedNodeName: # desired value is assigned to property 'nodeName'
        description: >-
          nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be scheduled right away as preemption victims receive their graceful termination periods.
          This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide to place the pod elsewhere if other nodes become available sooner.
          Scheduler may also decide to give the resources on this node to a higher priority pod that is created after preemption.
          As a result, this field may be different than PodSpec.nodeName when the pod is scheduled.
        type: string
      phase:
        description: >-
          The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
          The conditions array, the reason and message fields, and the individual container status arrays contain more detail about the pod's status. 
          Pending. The pod has been accepted by the Kubernetes system, but one or more of the container images has not been created.
          This includes time before being scheduled as well as time spent downloading images over the network.
          Running. The pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting.
          Succeeded. All containers in the pod have terminated in success, and will not be restarted.
          Failed. All containers in the pod have terminated, and at least one container has terminated in failure. The container either exited with non-zero status or was terminated by the system.
          Unknown. For some reason the state of the pod could not be obtained.
        type: string
#> contraints are not allowed for attributes before TOSCA 2.0
#       constraints:
#         - valid_values: [ Pending, Running, Succeeded, Failed, Unknown ]
      podIP:
        description: >-
          IP address allocated to the pod. Routable at least within the cluster. Empty if not yet allocated.
        type: string
      podIPs:
        description: >-
          podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6.
          This list is empty if no IPs have been allocated yet.
        type: list
        entry_schema:
          type: string
      qosClass:
        description: >-
          The Quality of Service (QOS) classification assigned to the pod based on resource requirements See PodQOSClass type for available QOS classes
        type: string
      reason:
        description: >-
          brief CamelCase message indicating details about why the pod is in this state. e.g. 'Evicted'
        type: string
      startTime:
        description: >-
          RFC 3339 date and time at which the object was acknowledged by the Kubelet. This is before the Kubelet pulled the container image(s) for the pod.
        type: string # TOSCA requires that a timestamp be inclosed in quotation marks. The matching Kubernetes type is 'Time'.
      # alpha      ephemeralContainerStatuses

    requirements:
        #NFV: virtual_storage
      - persistent_volume_claim:
          capability: tosca.capabilities.iolab.k8s.Pvc
          relationship: tosca.relationships.iolab.k8s.PersistentVolumeClaiming
          occurrences: [ 0, UNBOUNDED ]

    capabilities:
      pod_binding:  #>> Kubernetes pod.metadata.labels
        type: tosca.capabilities.iolab.k8s.PodLabels
        occurrences: [ 1, UNBOUNDED ]
    #> TODO:artifacts: property imagePullSecrets is is interpreted as an artifact.
      # imagePullSecrets:
      #  description: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored.
      #  type: list
      #    entry_schema:
      #    type: tosca.artifacts.iolab.k8s.LocalObjectReference
    interfaces:
      podLcm:
        type: tosca.interfaces.iolab.k8s.PodLcm

  #> In Kubernetes, Pods depends on their services, and not the opposite. So, we modelize Services as Nodes offering a capability required by Pod Nodes.
  #> - Excerpt from: https://kubernetes.io/docs/concepts/configuration/overview/
  #>    Create a Service before its corresponding backend workloads (Deployments or ReplicaSets), and before any workloads that need to access it. 
  #>    When Kubernetes starts a container, it provides environment variables pointing to all the Services which were running when the container was started. 
  #>    This does imply an ordering requirement - any Service that a Pod wants to access must be created before the Pod itself, or else the environment variables will not be populated. 

  #NFV: close to Cp
  tosca.nodes.iolab.k8s.Service:
    derived_from: tosca.nodes.Root
    description: >-
      Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, 
      and of the selector that determines which pods will answer requests sent through the proxy.
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      clusterIP:
        description: >-
          clusterIP is the IP address of the service and is usually assigned randomly by the master.
          If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail.
          This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address.
          "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName.
        type: string
        required: false
      externalIPs:
        description: >-
          externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.
          The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
        type: list
        entry_schema:
          type: string
        required: false
#>> TODO: This looks like a policy and can restricts the set of endpoints (?)
      externalTrafficPolicy:
        description: >-
          externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints.
          "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading.
          "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
        type: string
        constraints:
          - valid_values: [ Local, Cluster]
        required: false
      healthCheckNodePort:
        #!! complex constraint in description: TODO: property should exist only in LoadBalancerService
        description: >-
          healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort.
          Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
        type: integer
        required: false
      ipFamily:
        #!! complex constraint in description
        description: >-
          ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).
          If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.
          If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs)
          and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family. This field is immutable after creation.
          Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
        type: string
        required: false
      # property should exist only in LoadBalancerService: TODO
      loadBalancerSourceRanges:
        description: >-
          If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs.
          This field will be ignored if the cloud-provider does not support the feature.
        type: list
        entry_schema:
          type: string
        required: false
      ports:
        description: >-
          The list of ports that are exposed by this service.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.ServicePort
        required: false
      publishNotReadyAddresses:
        description: >-
          publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service.
          The default value is false. 
          The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
        type: boolean
        required: false
      selector:
        description: >-
          Route service traffic to pods with label keys and values matching this selector. 
          If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify.
          Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. 
        type: map
        entry_schema:
          type: string
        required: false

      sessionAffinity:
        description: >-
          Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None.
        type: string
        constraints:
          - valid_values: [ None, ClienIP ]
        default: None
        required: false
      sessionAffinityConfig:
        description: >-
          sessionAffinityConfig contains the configurations of session affinity.
        type: tosca.datatypes.iolab.k8s.SessionAffinityConfig
        required: false
      topologyKeys:
        #!! complex constraint in description
        description: >-
          topologyKeys is a preference-order list of topology keys which implementations of services should use to preferentially sort endpoints when accessing this Service,
          it can not be used at the same time as externalTrafficPolicy=Local. Topology keys must be valid label keys and at most 16 keys may be specified. 
          Endpoints are chosen based on the first topology key with available backends. If this field is specified and all entries have no backends that match the topology of the client,
          the service has no backends for that client and connections should fail. The special value "*" may be used to mean "any topology".
          This catch-all value, if used, only makes sense as the last value in the list. If this is not specified or empty, no topology constraints will be applied.
        type: list
        entry_schema:
          type: string
        required: false
#> TODO: Headless
#      type:
#        description: type determines how the Service is exposed. Defaults to . Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \"ExternalName\" maps to the specified externalName. \"ClusterIP\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is \"None\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. \"NodePort\" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. \"LoadBalancer\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP.
#        type: string
#        required: false
#        constraints:
#          - valid_values: [ ClusterIP, NodePort, LoadBalancer, ExternalName ]
#        default: ClusterIP
    attributes:
      metaAttributes:
        #>> Following description doesn't come from K8s
        description: >-
          The Kubernetes states that is populated by the system in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaAttributes
      loadBalancer:
        description: >-
          LoadBalancer contains the current status of the load-balancer, if one is present.
        type: tosca.datatypes.iolab.k8s.LoadBalancerStatus


  tosca.nodes.iolab.k8s.ClusterIPService:
    derived_from: tosca.nodes.iolab.k8s.Service
    description: >-
      A ClusterIPService allocates a cluster-internal IP address for load-balancing to endpoints.
      Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. 
      If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP.
#K    requirements:
#K      - podSelector:
#K          capability: tosca.capabilities.Node
#K          relationship: tosca.relationships.DependsOn
#K          occurrences: [ 1, UNBOUNDED ]

    capabilities:
      clusterIpExposition:
        type: tosca.capabilities.iolab.k8s.Exposition
        occurrences: [ 1, UNBOUNDED ]    
        

  tosca.nodes.iolab.k8s.ExternalNameService:
    derived_from: tosca.nodes.iolab.k8s.Service
    description: >-
      An ExternalName Service aliases this service to the specified externalName. 
    properties:
      # a pattern may be relevant here
      externalName:
        description: >-
          externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. 
          Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
        type: string
        required: false
    capabilities:
      externalNameExposure:
        type: tosca.capabilities.iolab.k8s.ExternalName
        occurrences: [ 1, 1 ]

  tosca.nodes.iolab.k8s.LoadBalancerService:
    derived_from: tosca.nodes.iolab.k8s.Service
    description: >-
      A LoadBalancer Service builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP.
    properties:
      loadBalancerIP:
        description: >-
          Only applies to Service Type. LoadBalancer LoadBalancer will get created with the IP specified in this field. 
          This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. 
          This field will be ignored if the cloud-provider does not support the feature.
        type: string
        required: false
    requirements:
      - podSelector:
          capability: tosca.capabilities.Node
          relationship: tosca.relationships.DependsOn
          occurrences: [ 1, UNBOUNDED ]
    capabilities:
      LoadBalancerExposure:
        type: tosca.capabilities.iolab.k8s.LoadBalancer
        occurrences: [ 1, 1 ]

  tosca.nodes.iolab.k8s.NodePortService:
    derived_from: tosca.nodes.iolab.k8s.Service
    description: >-
      A NodePort Service builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. 
    requirements:
      - podSelector:
          capability: tosca.capabilities.Node
          relationship: tosca.relationships.DependsOn
          occurrences: [ 1, UNBOUNDED ]
    capabilities:
      nodePortExposition:
        type: tosca.capabilities.iolab.k8s.Exposition
        occurrences: [ 1, UNBOUNDED ]    


#>> TODO: check whether NFV choose to use hosting requirements wrt. nodeSelector
#     - nodeSelector:
#        capability: tosca.capabilities.iolab.k8s.HostingNode
#          type: map
#          entry_schema:
#            type: string
#          description: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/

  # NFV: contains Vdu.VirtualBlockStorage
  tosca.nodes.iolab.k8s.PersistentVolumeClaim:
    description: >-
      PersistentVolumeClaim is a user's request for and claim to a persistent volume
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      accessModes:
        description: >-
          AccessModes contains the desired access modes the volume should have.
        type: list
        entry_schema:
          type: string
        required: false
      dataSource:
        description: >-
          This field can be used to specify either
          * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot - Beta)
          * An existing PVC (PersistentVolumeClaim)
          * An existing custom resource/object that implements data population (Alpha).
          In order to use VolumeSnapshot object types, the appropriate feature gate must be enabled (VolumeSnapshotDataSource or AnyVolumeDataSource)
          If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source.
          If the specified data source is not supported, the volume will not be created and the failure will be reported as an event.
          In the future, we plan to support more data source types and the behavior of the provisioner may change."
        type: tosca.datatypes.iolab.k8s.TypedLocalObjectReference
        required: false
      resources:
        description: >-
          Resources represents the minimum resources the volume should have.
        type: tosca.datatypes.iolab.k8s.ResourceRequirements
      selector:
        description: >-
          A label query over volumes to consider for binding.
        type: tosca.datatypes.iolab.k8s.LabelSelector
        required: false
      storageClassName:
        description: Name of the StorageClass required by the claim.
        type: string
        required: false
       # default and valid values are neither formally defined in the JSON API, nor in the API description field. it can be found in the Kubernetes documentation.
      volumeMode:
        description: >-
          volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
        type: string
        constraints:
          - valid_values: [ Filesystem, Block ]
        default: Filesystem
      volumeName:
        description: >-
          VolumeName is the binding reference to the PersistentVolume backing this claim.
        type: string
        required: false

    requirements:
      - pv_claiming:
          capability: tosca.capabilities.iolab.k8s.PersistentVolumeLabel
          relationship: tosca.relationships.iolab.k8s.PersistentVolumeConnection
          occurrences: [ 0, UNBOUNDED ]   #>> maximum to be checked

    capabilities:
      #NFV: = virtualStorage
      storageClaimable:
        type: tosca.capabilities.iolab.k8s.Pvc
        occurrences: [ 1, UNBOUNDED ]


  tosca.nodes.iolab.k8s.StatefulSet:
    derived_from: tosca.nodes.Root
    description: >-
      StatefulSet represents a set of pods with consistent identities. Identities are defined as:
      - Network':' A single stable DNS and hostname.
      - Storage':' As many VolumeClaims as requested.
      The StatefulSet guarantees that a given network identity will always map to the same storage identity.
    properties:
      metaProperties:
        description:  The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      podManagementPolicy:
        description: >-
          podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down.
          The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing.
          When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting,
          and on scale down will delete all pods at once.
        type: string
        constraints:
          - valid_values: [OrderedReady, Parallel ]
        default: OrderedReady
        required: false
      replicas:
        description: >-
          replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template,
          but individual replicas also have a consistent identity. If unspecified, defaults to 1.
        type: integer
        default: 1
        required: false
      revisionHistoryLimit:
        description: >-
          revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history.
          The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
        type: integer
        default: 10
        required: false
      selector:
        description: >-
          'selector' is a label query over pods that should match the replica count. It must match the pod template's labels.
        type: tosca.datatypes.iolab.k8s.LabelSelector
        required: true
  #>  TODO Make serviceName a requirement ?
      serviceName:
        description: >-
          'serviceName' is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. 
          Pods get DNS/hostnames that follow the pattern':' pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.
        type: string
        required: true
      template:
        description: >-
          'template' is the object that describes the pod that will be created if insufficient replicas are detected.
          Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
        type: tosca.datatypes.iolab.k8s.PodTemplateSpec
        required: true
      updateStrategy:
        description: >-
          updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
        type: tosca.datatypes.iolab.k8s.StatefulSetUpdateStrategy

    requirements:
      # 'volumeClaimTemplates' is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims
      # in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. 
      # A claim in this list takes precedence over any volumes in the template, with the same name.
      - volumeClaimTemplates:
          capability: tosca.capabilities.iolab.k8s.Pvc
          relationship: tosca.relationships.iolab.k8s.PersistentVolumeClaiming
          occurrences: [ 0, UNBOUNDED ]
      - exposing:
          capability: tosca.capabilities.iolab.k8s.Exposition
          relationship: tosca.relationships.iolab.k8s.ExposedAs
          occurrences: [ 0, UNBOUNDED ]        

group_types:

    #>> Relationship targets used for management purpose only, as opposed to tosca.capabilities.iolab.k8s.PodLabel
  tosca.groups.iolab.k8s.PodSelector:    #>> LabelSelector applied on pods
    derived_from: tosca.groups.Root
    members: [tosca.nodes.iolab.k8s.Pod]    # tosca 'members' matches K8S template property


policy_types:

#> The K8S Pod.affinity property is of type Affinity, whose properties are nodeAffinity, of type NodeAffinity, podAffinity, of type PodAffinity, and podAntiAffivilty, of Type PodAntiAffinity
#> Given their semantics, they are expressed as TOSCA policies. This is reinforced by NFV approach of these notions.
  tosca.policies.iolab.k8S.NodeAffinity:
    derived_from: tosca.policies.Root
    description: >-
      Node affinity is a group of node affinity scheduling rules.
    properties:
      preferredDuringSchedulingIgnoredDuringExecution:
        description: >-
          The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
          The node that is most preferred is the one with the greatest sum of weights,
          i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.),
          compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions;
          the node(s) with the highest sum are the most preferred.
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.PreferredSchedulingTerm
      requiredDuringSchedulingIgnoredDuringExecution:
        description: >-
          If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
          If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update),
          the system may or may not try to eventually evict the pod from its node.
        type: tosca.datatypes.iolab.k8s.NodeSelector
    targets: [ tosca.nodes.iolab.k8s.Pod ]

  tosca.policies.iolab.k8s.ReplicaSet:
    derived_from: tosca.policies.Root
    description: >-
      ReplicaSetSpec is the specification of a ReplicaSet.
    properties:
      metaProperties:
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false
      minReadySeconds:
        description: >-
          Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available.
          Defaults to 0 (pod will be considered available as soon as it is ready)
        type: integer
        default: 0
      replicas:
        description: >-
          Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
        type: integer
        default: 1    #>>unspecified in K8S json API
#> The k8s template property is replaced by the policy keyname 'target'
#> It could be the same for the selector property, but maybe it could be expressed as property_filter, which may not beallowed in TOSCA 2
#      selectors:
#        description: Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels.
#        type: tosca.datatypes.iolab.k8s.LabelSelector
    targets: [ tosca.groups.iolab.k8s.PodSelector ]
#> ? If needed, K8S ReplicaSetStatus may be seen as an interface holding notifications


#> Defined by K8S as a policy type (io.k8s.api.networking.v1.NetworkPolicy):
  tosca.policies.iolab.k8s.NetworkPolicy:
    derived_from: tosca.policies.Root
    description: >-
      NetworkPolicy describes what network traffic is allowed for a set of Pods.
    properties:
      metaProperties:
        #>> Following description doesn't come from K8s
        description: >-
          The Kubernetes states that can be specified by users in the corresponding object metadata.
        type: tosca.datatypes.iolab.k8s.ObjectMetaProperties
        required: false     
      egress:
        description: >-
          List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the traffic),
          OR if the traffic matches at least one egress rule across all of the NetworkPolicy objects whose podSelector matches the pod.
          If this field is empty then this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the pods it selects are isolated by default).
          This field is beta-level in 1.8
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.NetworkPolicyEgressRule
        required: false
      ingress:
        description: >-
          List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the traffic),
          OR if the traffic source is the pod's local node, OR if the traffic matches at least one ingress rule across all of the NetworkPolicy objects whose podSelector matches the pod.
          If this field is empty then this NetworkPolicy does not allow any traffic (and serves solely to ensure that the pods it selects are isolated by default)
        type: list
        entry_schema:
          type: tosca.datatypes.iolab.k8s.NetworkPolicyIngressRule
        required: false
      policyTypes:
        description: >-
          List of rule types that the NetworkPolicy relates to. Valid options are "Ingress", "Egress", or "Ingress,Egress".
          If this field is not specified, it will default based on the existence of Ingress or Egress rules;
          policies that contain an Egress section are assumed to affect Egress, and all policies (whether or not they contain an Ingress section) are assumed to affect Ingress.
          If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
          Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include "Egress"
          (since such a policy would not include an Egress section and would otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        type: list
        entry_schema:
          type: string

    targets: [ tosca.groups.iolab.k8s.PodSelector ]
    #> part of description in k8s API: 
    #  Multiple network policies can select the same set of pods. In this case, the ingress rules for each are combined additively. 
    # This field is NOT optional and follows standard label selector semantics. 
    #>>!! An empty podSelector matches all pods in this namespace.

